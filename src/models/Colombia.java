package models;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.jfree.data.category.DefaultCategoryDataset;

import exceptions.DepartmentNotFoundException;
import exceptions.InvalidConstantException;
import exceptions.MineNotFoundException;
import models.utils.MatrixReport;

public class Colombia {
	private Department[] listDepartment;
	
	public Colombia() {
		listDepartment = new Department[10]; 
	}
	
	public void autogenerateDepartment() {
		for (int i = 0; i < listDepartment.length; i++) {
			try {
				listDepartment[i] = new Department(DepartmentName.values()[i],25000000);
			} catch (MineNotFoundException e) {
				e.printStackTrace();
			}
		}
	}
	
	public int searchDepartment(DepartmentName name) throws DepartmentNotFoundException {
		for (int i = 0; i < listDepartment.length; i++) {
			if(listDepartment[i].getName().equals(name.getName()))
				return i;
		}
		throw new DepartmentNotFoundException();
	}
	
	public void createMine(DepartmentName department, String nameMine,int meter, OreType oreType, int kilogramPrice, int id, MineType mineType,int budgetMine) throws DepartmentNotFoundException {
		listDepartment[searchDepartment(department)].addMine(new Mine(nameMine,meter,oreType, kilogramPrice,id,mineType,budgetMine));
	}
	
	public void sendRemoveMine(DepartmentName department, int id) throws MineNotFoundException {
		for (Department department2 : listDepartment) {
			if(department2.getName().equals(department.getName()))
				department2.removeMine(id);
		}
	}
	
	public Department[] getListDepartment() {
		return listDepartment;
	}
	
	public void editKilogramPriceMine(DepartmentName department, int id, int newKilogramPrice) throws MineNotFoundException, DepartmentNotFoundException {
		listDepartment[searchDepartment(department)].editKilogramPrice(newKilogramPrice, id);
	}
	
	public void editOreType(DepartmentName department, int idMine, OreType oreType) throws MineNotFoundException, DepartmentNotFoundException {
		listDepartment[searchDepartment(department)].editOreType(oreType, idMine);
	}
	
	public void editMineType(DepartmentName department, int idMine, MineType type) throws MineNotFoundException, DepartmentNotFoundException {
		listDepartment[searchDepartment(department)].editMineType(type, idMine);
	}
	
	public void sellOre(DepartmentName department, int idMine, int kilos) throws MineNotFoundException, DepartmentNotFoundException {
		listDepartment[searchDepartment(department)].sellOre(idMine, kilos);
	}
	
	public void buyInsumes(DepartmentName department, int idMine, int mount) throws MineNotFoundException, DepartmentNotFoundException {
		listDepartment[searchDepartment(department)].buyInsumes(idMine, mount);
	}
	
	public Object[] generateReportGainsPerMine(DepartmentName dep) throws DepartmentNotFoundException {
//		DefaultCategoryDataset data = new DefaultCategoryDataset();
		DefaultCategoryDataset data = new DefaultCategoryDataset();
		List<Mine> list = listDepartment[searchDepartment(dep)].getListMine();
		for (int i = 0; i < list.size(); i++) {
			data.addValue(list.get(i).getGain(), list.get(i).getName(), "Minas");
		}
		return new Object[] { data, dep.getName() };
	}
	
	public void generateReportGains() {
		
	}
	
	public Object[] generateReportMinesPerDepartment() throws InvalidConstantException {
		Map<String,Integer> data = new HashMap<String,Integer>();
		for (int i = 0; i < listDepartment.length; i++) {
			data.put(listDepartment[i].getName(),listDepartment[i].getListMine().size());
		}
		return MatrixReport.generateMatrixReport(data, MatrixReport.DEPART);
	}
	public 	Object[] generateReportM2perDepartment() throws InvalidConstantException{
		Map<String,Integer> data = new HashMap<String,Integer>();
		for (int i = 0; i < listDepartment.length; i++) {
			data.put(listDepartment[i].getName(),searchQuantityM2PerDepartment(i));
		}
		return MatrixReport.generateMatrixReport(data, MatrixReport.DEPART);
		
	}
	public int searchQuantityM2PerDepartment(int count) {
		int counter = 0;
			for (int j = 0; j < listDepartment[count].getListMine().size(); j++) {
			
					counter += listDepartment[count].getListMine().get(j).getMeter() ;
			}
		
		return counter;
	}
	public Object[] generateReportMinesPerOre() throws InvalidConstantException {
		Map<String, Integer> data = new HashMap<String, Integer>();
		for (int i = 0; i < OreType.values().length; i++) {
			OreType ore = OreType.values()[i];
			data.put(ore.getOreType(), searchQuantityMines(ore));
		}
		return MatrixReport.generateMatrixReport(data, MatrixReport.ORE);
	}
	
	public int searchQuantityMines(OreType ore) {
		int counter = 0;
		for (int i = 0; i < listDepartment.length; i++) {
			for (int j = 0; j < listDepartment[i].getListMine().size(); j++) {
				if(listDepartment[i].getListMine().get(j).getOreType() == ore )
					counter++;
			}
		}
		return counter;
	}
	
	public DefaultCategoryDataset generateReportGain() {
		DefaultCategoryDataset data = new DefaultCategoryDataset();
		for (int i = 0; i < listDepartment.length; i++) {
			data.addValue(listDepartment[i].getGain(), listDepartment[i].getName(), "Departamentos");
		}
		return data;
	}
	
	public Object[] generateReportQuantityTypeMines(){
		Map<String,Integer> data = new HashMap<String,Integer>();
		for (int i = 0; i < MineType.values().length; i++) {
			MineType mine = MineType.values()[i];
			data.put(mine.getMineType(), searchQuantityTypeMines(mine));
		}
		return MatrixReport.generateMatrixReport(data, MatrixReport.TYPE_MINE);
	}
	
	public int searchQuantityTypeMines(MineType mine) {
		int counter = 0;
		for (int i = 0; i < listDepartment.length; i++) {
			for (int j = 0; j < listDepartment[i].getListMine().size(); j++) {
				if(listDepartment[i].getListMine().get(j).getMineType() == mine)
					counter++;
			}
		}
		return counter;
	}
	
}